#lang racket
(require 2htdp/image)
(require lang/posn)
(require 2htdp/universe)

;; Blatt 6

;; 1 --- Formen der Rekursion (10 Punkte)
#|
Endrekursion:
Rekursive Funktionen, bei denen das Ergebnis der Rekursion nicht mehr mit anderen Termen
verknüpft werden muß, heißen endrekursiv (engl. tail-recursion).
Die zugehörigen Prozesse heißen iterative Prozesse.

Lineare Rekursion:
Eine Funktionsdefinition, die sich auf der rechten Seite der definierenden Gleichung in jeder
Fallunterscheidung selbst nur einmal verwendet, heißt Rekursion: linear-rekursiv

Baumartige Rekursion:
Eine rekursive Definition ist baumartig, wenn in der Definition in einer Fallunterscheidung
mehrfach auf die Definition Bezug genommen wird.

Geschachtelte Rekursion:
Eine Rekursion ist geschachtelt, wenn die Funktion in der rekursiven Verwendung selbst als
Argument mitgegeben wird.

Direkte Rekursion:
Eine Methode heißt direkt rekursiv, wenn der erneute Aufruf im Methodenrumpf der Methode erfolgt.

Indirekte Rekursion:
Eine rekursive Definiton heißt indirekt oder verschränkt, wenn zwei oder mehrere Definitionen
sich wechselseitig rekursiv verwenden.
|#


;; 2 --- Ihre Nikolausaufgabe (20 Punkte)
(define scene
  ; definiert die Größe der Szene und die Hintergrundfarbe
  (empty-scene 900 500 (color 25 25 80)))

(define ground
  ; Schneeboden
  (crop/align "right" "top"
              1000 200
              (ellipse 1800 300 "solid" "whitesmoke")))

(define (oneStar size)
  ; ein Stern
  (radial-star 8 2 size "solid" (color 255 255 153)))

(define (stars n)
  ; Sterne
  (if (> n 0)
      (underlay/offset
       (oneStar (random 2 20))
       (random 900) (random 500)
       (stars (- n 1)))
      (oneStar (random 2 20))))

(define (tree size greenColor)
  ; Hintergrundbaum
  (if (> size 0)
      (overlay/align/offset "middle" "middle"
                            (triangle size "solid" (color 0 greenColor 0))
                            0 (* size -0.4)
                            (tree (- size 15) greenColor))
      (triangle 0 "solid" (color 0 greenColor 0))))

(define (trees number)
  ; erzeugt Hintergrundbäume
  (if (> number 1)
      (overlay/offset
        (tree (random 100 300) (random 50 100))
        (random 600) 0
        (trees (- number 1)))
      (tree (random 100 300) (random 50 100))))

(define (treeLeaves size)
  ; erzeugt den Weihnachtsbaume ohne Stamm
  (if (> size 0)
      (underlay/align/offset "middle" "middle"
                            (pulled-regular-polygon size 3 1/5 30 "solid" (color 34 160 34))
                            0 (* size -0.4)
                            (treeLeaves (- size 30)))
      (star 25 "solid" "gold")))

(define christmasTree
  ; erzeugt Weihnachtsbaum mit Stamm
  (overlay/align/offset
   "middle" "bottom"
   (treeLeaves 200)
   0 10
   (pulled-regular-polygon 50 4 1/5 30 "solid" "sienna")))

(define placeStars
  ;platziert Hintergrundbäume in Szene
  (place-image (stars 200)
               900 400
               scene))

(define placeTrees
  ;platziert Hintergrundbäume in Szene
  (place-image (trees 100)
               (random 300 600) 300
               placeStars))

(define placeGround
  ;platziert Boden in Szene
  (place-image/align
   ground
   0 500 "left" "bottom"
   placeTrees))

(define placeChristmasTree
  ;platziert Weihnachstsbaum in Szene
  (place-image/align
   christmasTree
   200 275 "middle" "middle"
   placeGround))


; erzeugt das Bild:
placeChristmasTree




#|
(color red green blue alpha) 0-255

mode: "outline", "solid"
   (circle radius mode color)
   (ellipse width height mode color)
(triangle side-length mode color)
(right-triangle bottom-length left-side-length mode color)
   (isosceles-triangle size angle mode color)
(triangle/sss) - (triangle/saa) ...
(square side-length mode color)
   (rectangle width height mode color)
   (rhombus height width mode color)
   (star size mode color)
(star-polygon size point-count mit-dem-wievielten-spike-verbinden mode color)
   (radial-star point-count inner-radius outer-radius/size mode color)
(regular-polygon size point-count mode color)
   (pulled-regular-polygon size point-count pull angle mode color)
   (polygon vertices(listofpoints) mode color)
(add-polygon) ...
(scene+polygon) ...

(line x y color)
(add-solid-curve) ...
(text string font-size color)
(text/font) ...

x/y-place: "middle" "right" "left" "bottom" "top"
(overlay image-oben image-unten ...)
   (overlay/align x-place y-place image-oben image-unten ...)
   (overlay/offset image-oben x-right y-down image-unten)
(overlay/align/offset) ...
   (overlay/xy image-oben x y image-unten)

(beside) ...
(above) ...

(empty-scene width height color)
(place-image image x y scene)
(place-image/align x y x-place y-place scene/image)
(place-images images-list posns-list scene)
(place-images/align) ...

(rotate angle image)
(scale factor image)
(scale/xy x-factor y-factor image) ;Verzerrung
(flip-horizontal image)
(flip-vertical image)
(crop x y width height image)
(crop/align x-place y-place width height image)
|#









;; 2.1 - Zusatzaufgabe 1 (5 Zusatzpunkte)
;; 2.2 - Zusatzaufgabe 2 (5 Zusatzpunkte)
#|
(define  UFO
  (underlay/align "center"
                  "center"
                  (circle  10 "solid" "green")
                  (rectangle  40 4 "solid" "green")))

(define  UFO-BEAM
  (above/align "center"
               (underlay/align "center" "center"
                               (circle  10 "solid" "green")
                               (rectangle  40 4 "solid" "green"))
               (isosceles-triangle  100 20 "solid" "yellow")))

(define (create-UFO-scene t)
  (let (( height (* (sin (/ t 30))  50)))
    (underlay/xy (rectangle  500 100 "solid" "white")
                 (modulo t 500)  height
                 (if (< 0 height) UFO  UFO-BEAM ))))

(animate  create-UFO-scene)
|#




  