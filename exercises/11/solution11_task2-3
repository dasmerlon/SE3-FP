#lang lazy

;; 2 --- Memo-Funktionen (5 Punkte)
(define (memo fn)
  ;Implementation der memo Tabelle als Assoziationsliste
  (letrec
      ([table '()]
       [store (lambda (arg val)
                (set! table 
                      (cons (cons arg val) table)) val)]
       [retrieve
        (lambda (arg)
          (let ((val-pair (assoc arg table)))
            (if 
             val-pair 
             (cdr val-pair)
             #f )))]
       [ensure-val
        (lambda (x)
          (let ([stored-val (retrieve x)])
            (if
             stored-val
             stored-val
             (store x (fn x)))))])
    ensure-val))

(define (harmonische-reihe n)
  ;Die Funktion zur Berechnung der harmonischen Reihe
  (if (= n 1)
      n
      (+ (/ 1 n) (harmonische-reihe (- n 1)))))

;Die Memo-Funktion für die harmonische Reihe
(define memo-harm (memo harmonische-reihe))


;; 3 --- Stromorientierte Programmierung (10 Punkte)
(define (natsAbN n)
  ; Erzeugt einen Strom natürlicher Zahlen, angefangen mit n
  (cons n (natsAbN (+ n 1))))

(define (devisible? x y)
  ; Prüft, ob eine Zahl glatt durch eine andere teilbar ist
  (= 0 (remainder x y)))

(define (chooseFlipFlap x)
  ; Wählt basierend der Zahl x aus, ob flipflap, flip oder flap ausgegeben werden soll.
  ; Sonst soll die Zahl wieder gegeben werden.
  ; Die erste Bedingung (not integer?) ist nötig, da der Eingabestrom auch schon flips,
  ; flaps und flipflaps enthält.
  (cond
    [(not (integer? x)) x]
    [(and (devisible? x 3)(devisible? x 5)) "flipflap"]
    [(devisible? x 3) "flip"]
    [(devisible? x 5) "flap"]
    [else x]))

(define (sieve stream)
  ; Siebt den Strom mit map auf jedem ELement
  (cons (car stream)
        (map (lambda (x) (chooseFlipFlap x))
             (sieve (cdr stream)))))

(define flipflap
  ; Definiert den Strom mit dem Sieb
  (sieve (natsAbN 1)))

(define (test n)
  ; Die Testfunktion, die n-viele ELemente aus dem Stream entnimmt
  (!! (take n flipflap)))

;Zum Testen:
;(test 50)
